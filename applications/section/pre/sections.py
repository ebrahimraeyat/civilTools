import os
import sys

import numpy as np
import matplotlib
matplotlib.use('Qt5Agg')
import matplotlib.pyplot as plt

section_path = os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir))
sys.path.insert(0, section_path)
from pre import pre
from post import post
from analysis.cross_section import CrossSection


# TODO: ensure dimensions are floats

class Geometry:
    """Parent class for a cross-section geometry input.

    Provides an interface for the user to specify the geometry defining a
    cross-section. A method is provided for generating a triangular mesh, for
    translating the cross-section by *(x, y)* and for plotting the geometry.

    :cvar points: List of points *(x, y)* defining the vertices of the
        cross-section
    :vartype points: list[list[float, float]]
    :cvar facets: List of point index pairs *(p1, p2)* defining the edges of
        the cross-section
    :vartype facets: list[list[int, int]]
    :cvar holes: List of points *(x, y)* defining the locations of holes within
        the cross-section. If there are no holes, provide an empty list [].
    :vartype holes: list[list[float, float]]
    :cvar control_points: A list of points *(x, y)* that define different
        regions of the cross-section. A control point is an arbitrary point
        within a region enclosed by facets.
    :vartype control_points: list[list[float, float]]
    :cvar shift: Vector that shifts the cross-section by *(x, y)*
    :vartype shift: list[float, float]
    """

    def __init__(self, xs=None, ys=None, control_points=None, holes=None, type_='IPE'):
        """Inits the Geometry class."""
        if xs:
            self.type_ = type_
            self.xs = xs
            self.ys = ys
            self.control_points = control_points
            self.holes = holes
            self.points = self.create_points()
            self.facets = self.create_facets()
        else:
            self.control_points = []
            self.points = []
            self.facets = []
            self.holes = []

    def create_points(self):
        return [(x, y) for x, y in zip(self.xs, self.ys)]

    def create_facets(self):
        return [(i, i + 1) for i in range(-1, len(self.xs) - 1)]

    def create_mesh(self, mesh_sizes):
        """Creates a quadratic triangular mesh from the Geometry object.

        :param mesh_sizes: A list of maximum element areas corresponding to
            each region within the cross-section geometry.
        :type mesh_size: list[float]

        :return: Object containing generated mesh data
        :rtype: :class:`meshpy.triangle.MeshInfo`

        :raises AssertionError: If the number of mesh sizes does not match the
            number of regions

        The following example creates a circular cross-section with a diameter
        of 50 with 64 points, and generates a mesh with a maximum triangular
        area of 2.5::

            import sectionproperties.pre.sections as sections

            geometry = sections.CircularSection(d=50, n=64)
            mesh = geometry.create_mesh(mesh_sizes=[2.5])

        ..  figure:: ../images/sections/circle_mesh.png
            :align: center
            :scale: 75 %

            Mesh generated from the above geometry.
        """

        str = "Number of mesh_sizes ({0}), ".format(len(mesh_sizes))
        str += "should match the number of regions "
        str += "({0}).".format(len(self.control_points))
        assert(len(mesh_sizes) == len(self.control_points)), str

        return pre.create_mesh(self.points, self.facets, self.holes,
                               self.control_points, mesh_sizes)

    def plot_geometry(self, ax=None, pause=True, labels=False):
        """Plots the geometry defined by the input section. If no axes object
        is supplied a new figure and axis is created.

        :param ax: Axes object on which the mesh is plotted
        :type ax: :class:`matplotlib.axes.Axes`
        :param bool pause: If set to true, the figure pauses the script until
            the window is closed. If set to false, the script continues
            immediately after the window is rendered.
        :param bool labels: If set to true, node and facet labels are displayed

        The following example creates a CHS discretised with 64 points, with a
        diameter of 48 and thickness of 3.2, and plots the geometry::

            import sectionproperties.pre.sections as sections

            geometry = sections.Chs(d=48, t=3.2, n=64)
            geometry.plot_geometry()

        ..  figure:: ../images/sections/chs_geometry.png
            :align: center
            :scale: 75 %

            Geometry generated by the above example.
        """

        # if no axes object is supplied, create and setup the plot
        if ax is None:
            ax_supplied = False
            (fig, ax) = plt.subplots()
            post.setup_plot(ax, pause)
        else:
            ax_supplied = True

        for (i, f) in enumerate(self.facets):
            # plot the points and facets
            if i == 0:
                ax.plot([self.points[f[0]][0], self.points[f[1]][0]],
                        [self.points[f[0]][1], self.points[f[1]][1]],
                        'ko-', markersize=2, label='Points & Facets')
            else:
                ax.plot([self.points[f[0]][0], self.points[f[1]][0]],
                        [self.points[f[0]][1], self.points[f[1]][1]],
                        'ko-', markersize=2)

        for (i, h) in enumerate(self.holes):
            # plot the holes
            if i == 0:
                ax.plot(h[0], h[1], 'rx', markerSize=5, label='Holes')
            else:
                ax.plot(h[0], h[1], 'rx', markerSize=5)

        for (i, cp) in enumerate(self.control_points):
            # plot the control points
            if i == 0:
                ax.plot(cp[0], cp[1], 'bo', markerSize=5,
                        label='Control Points')
            else:
                ax.plot(cp[0], cp[1], 'bo', markerSize=5)

        # display the legend
        ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

        # display the labels
        if labels:
            # plot node labels
            for (i, pt) in enumerate(self.points):
                ax.annotate(str(i), xy=pt, color='r')

            # plot facet labels
            for (i, fct) in enumerate(self.facets):
                pt1 = self.points[fct[0]]
                pt2 = self.points[fct[1]]
                xy = [(pt1[0] + pt2[0]) / 2, (pt1[1] + pt2[1]) / 2]

                ax.annotate(str(i), xy=xy, color='b')

        # if no axes object is supplied, finish the plot
        if not ax_supplied:
            post.finish_plot(ax, pause, title='Cross-Section Geometry')


class MergedSection(Geometry):
    """Merges a number of section geometries into one geometry. Note that for
    the meshing algorithm to work, there needs to be connectivity between all
    regions of the provided geometries. Overlapping of geometries is permitted.

    :param sections: A list of geometry objects to merge into one
        :class:`~sectionproperties.pre.sections.Geometry` object
    :type sections: list[:class:`~sectionproperties.pre.sections.Geometry`]

    The following example creates a combined cross-section with a 150x100x6 RHS
    placed on its side on top of a 200UB25.4. A mesh is generated with a
    maximum triangle size of 5.0 for the I-section and 2.5 for the RHS::

        import sectionproperties.pre.sections as sections

        isection = sections.ISection(d=203, b=133, t_f=7.8, t_w=5.8, r=8.9, n_r=8)
        box = sections.Rhs(d=100, b=150, t=6, r_out=15, n_r=8, shift=[-8.5, 203])

        geometry = sections.MergedSection([isection, box])
        geometry.clean_geometry()
        mesh = geometry.create_mesh(mesh_sizes=[5.0, 2.5])

    ..  figure:: ../images/sections/merged_geometry.png
        :align: center
        :scale: 75 %

        Merged section geometry.

    ..  figure:: ../images/sections/merged_mesh.png
        :align: center
        :scale: 75 %
    """

    def __init__(self, sections):
        """Inits the MergedSection class."""

        super().__init__()

        point_count = 0

        # loop through all sections
        for section in sections:
            # add facets
            for facet in section.facets:
                self.facets.append([facet[0] + point_count,
                                    facet[1] + point_count])

            # add points and count points
            for point in section.points:
                self.points.append([point[0], point[1]])
                point_count += 1

            # add holes
            for hole in section.holes:
                self.holes.append([hole[0], hole[1]])

            # add control points
            for control_point in section.control_points:
                self.control_points.append([control_point[0],
                                            control_point[1]])


if __name__ == '__main__':
    # import sys

    xs = [0, 65, 65, 7.5, 7.5, 65, 65, 0, 0]
    ys = [0, 0, 10.5, 10.5, 149.5, 149.5, 160, 160, 0]
    cp1 = [(3.75, 80.0)]
    unp1 = Geometry(xs, ys, cp1, 'UNP')

    xs = [130.0, 65.0, 65.0, 122.5, 122.5, 65.0, 65.0, 130.0, 130.0]
    ys = [0, 0, 10.5, 10.5, 149.5, 149.5, 160, 160, 0]
    cp2 = [(126.25, 80.0)]
    unp2 = Geometry(xs, ys, cp2, 'UNP')

    geometry = MergedSection([unp1, unp2])
    geometry.holes.append([(3.75 + 126) / 2, 80])
    mesh = geometry.create_mesh(mesh_sizes=[2.5, 2.5])
    section = CrossSection(geometry, mesh)  # create a CrossSection object
    section.plot_mesh()
    # geometry.plot_geometry()
