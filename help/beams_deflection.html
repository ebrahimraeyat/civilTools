<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>beams_deflection</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="beams_deflection_files/libs/clipboard/clipboard.min.js"></script>
<script src="beams_deflection_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="beams_deflection_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="beams_deflection_files/libs/quarto-html/popper.min.js"></script>
<script src="beams_deflection_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="beams_deflection_files/libs/quarto-html/anchor.min.js"></script>
<link href="beams_deflection_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="beams_deflection_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="beams_deflection_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="beams_deflection_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="beams_deflection_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="کنترل-خودکار-خیز-تیرها" class="level2" dir="rtl">
<h2 class="anchored" data-anchor-id="کنترل-خودکار-خیز-تیرها">کنترل خودکار خیز تیرها</h2>
<!-- <div dir=rtl> -->
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true" href="">سیویل‌تولز</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false" href="">ایتبز</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-3" role="tab" aria-controls="tabset-1-3" aria-selected="false" href="">تکنیکال</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<p>مراحل کنترل خیز در نرم افزار سیویل تولز به شرح زیر است:</p>
<ol class="example" type="1">
<li><strong>انتخاب تیرهای مورد نظر</strong></li>
</ol>
<p>ابتدا کاربر تیرهایی که قصد کنترل خیز آنها را دارد، در مدل ایتبز انتخاب میکند. در این مرحله کاربر میتواند همه مدل را انتخاب کند، گرچند این کار توصیه نمیشود. چون زمان تحلیل را افزایش میدهد. در خصوص کنسولها نکته ای وجود دارد که میتوانید در این قسمت ملاحظه کنید.</p>
<p><img src="figures/beams_deflection/select_beams_in_etabs.png" class="img-fluid"></p>
<ol start="2" class="example" type="1">
<li><strong>اجرای دستور کنترل خیز تیرها</strong></li>
</ol>
<p>دستور کنترل خیز را از منوی Control&gt; Beam Deflection و یا از طریق آیکون برنامه اجرا کنید.</p>
<p><img src="figures/beams_deflection/execute_deflection_of_beams.png" class="img-fluid"></p>
<ol start="3" class="example" type="1">
<li><strong>انجام تنظیمات</strong></li>
</ol>
<p>بعد از اجرای دستور کنترل خیز، پنجره زیر نمایش داده میشود که بیشتر موارد این پنجره به طور خودکار پر میشود. معمولا بخش ۲ نیاز به تنظیم دارد.</p>
<p><img src="figures/beams_deflection/beam_deflection_window_after_exect.png" class="img-fluid"></p>
<p>۱- در این قسمت نوع بارها از تنظیمات فایل ایتبز خوانده و جایگذاری میشود. همچنین مقدار درصد بار زنده از تنظیمات نرم افزار سیویل تولز خوانده میشود. اسم فایل کنترل خیز نیز در قسمت FileName وارد میشود.</p>
<p>۲- در این قسمت کاربر برای تمامی تیرها تنظیمات لازم را انجام میدهد.</p>
<ul>
<li>Console: اگر تیر مورد نظر کنسول است این گزینه تیک زده شود.</li>
<li>Minus Length: با توجه به اینکه برای بدست آوردن خیز مجاز نیاز به طول خالص تیر می باشد، لذا در این قسمت کاربر عددی به سانتی متر وارد میکند که از طول کل تیر کم میشود.</li>
<li>Torsion Rebar: مقدار مساحت میلگرد پیچشی تیر در محاسبه درصد میلگرد لحاظ میگردد.</li>
<li>Add Rebar: با توجه به اینکه محاسبات میلگرد ایتبز با نقشه ها متفاوت می باشد، کاربر میتواند میلگرد اضافی مورد نیاز را در این قسمت وارد کند.</li>
</ul>
<p>۳- تنظیم معیارهای کنترل خیز</p>
<p>در این قسمت کاربر معیارهایی که برای کنترل خیز کوتاه مدت و دراز مدت برای تیرهای کنسول و یکسره مد نظر دارد را وارد میکند. این تنظیمات را میتوان برای یکبار و همه مدلها در قسمت تنظیمات نرم افزار سیویل تولز انجام داد، برای اینکار از منوی Edit&gt; Preferences نرم افزار سیویل تولز را انتخاب کنید.</p>
<p><img src="figures/beams_deflection/civiltools_settings_control.png" class="img-fluid"></p>
<ol start="4" class="example" type="1">
<li><strong>چک کردن خیز</strong></li>
</ol>
<p>با زدن کلید Check فرایند کنترل خیز تیرها شروع میشود. این فرایند نسبتا زمانبر است. نکته ای که وجود دارد، اگر در فایل اصلی و بعد از طراحی سازه، نرم افزار متوقف شد، پنجره فعلی را بسته و مجددا دستور را اجرا کنید. تمام تنظیمات ذخیره شده و فقط کافیست که دوباره کلید Check را بزنید.</p>
<ol start="5" class="example" type="1">
<li><strong>نمایش نتایج</strong></li>
</ol>
<p>پس از پایان فرایند کنترل خیز، نتایج به صورت رنگی نمایش داده میشود:</p>
<ul>
<li><p>قسمت ۴- خلاصه کنترل خیز تیر انتخاب شده را نشان میدهد. deflection1 خیز کوتاه مدت و deflection2 خیز دراز مدت می باشد.</p></li>
<li><p>قسمت ۵- تیر انتخاب شده را در پلان طبقه نمایش میدهد.</p></li>
<li><p>قسمت ۶- روند کنترل خیز تیر و جزيیات رانشان میدهد.</p></li>
</ul>
<p><img src="figures/beams_deflection/show_results.png" class="img-fluid"></p>
<ul>
<li>رنگ آبی: کنترل خیز تیر جواب داده است.</li>
<li>رنگ زرد: خیز بلند مدت جواب نداده است.</li>
<li>رنگ قرمز: خیز کوتاه مدت جواب نداده است.</li>
</ul>
<ol start="6" class="example" type="1">
<li><strong>گزارش کنترل خیز</strong></li>
</ol>
<p>در نهایت با زدن کلید Report یک گزارش از کنترل خیز تمامی تیرها به فرمت word ایجاد میشود.</p>
<p><img src="figures/beams_deflection/word_report.png" class="img-fluid"></p>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<p>به منظور کنترل خیز تیرها در نرم افزار ایتبز مراحل زیر را انجام میدهیم:</p>
<ol start="7" class="example" type="1">
<li>تحلیل و طراحی سازه بتنی اصلی</li>
<li>بدست آوردن نسبت میلگرد تیرها و ضریب <span class="math inline">\(\lambda_\Delta\)</span></li>
<li>ذخیره فایل اصلی با نام دیگر</li>
<li>تغییر سختی اعضا</li>
<li>ایجاد لودکیس و ترکیب بارهای غیرخطی</li>
<li>انجام تحلیل ترک‌خوردگی و مشاهده نتایج</li>
</ol>
<p>برای کنترل خیز تیرها اولین کاری که باید انجام بدهیم بدست آوردن میلگرد های تیر هست که البته توسط نرم‌افزار ایتبس محاسبه می شود. نکته مهم در این قسمت این است که آرماتور های پیچشی نیز باید محاسبه و منظور شوند. محاسبه آرماتور های پیچشی باید در فایلی که ضریب خمشی سقف ها( درصورت مدل سازی به صورت shell) برابر 0.25 است انجام گیرد. چون در این صورت خمش ناشی از سقف باعث افزایش میلگرد های پیچشی تیرها می شوند. ضریب ترک خوردگی تیر و ستون ها نیز به ترتیب 0.35 و 0.7 می باشند.</p>
<p>پس از طراحی سازه باید مقدار درصد میلگرد تیرها برداشت شود(برای تیرهای پیوسته یا ساده در وسط دهانه و بالای مقطع و در تیرهای طره در بر تکیه گاه و در پایین مقطع) . تا با استفاده از درصد میلگرد فشاری تیرها (<span class="math inline">\(\rho\)</span>) , <span class="math inline">\(\lambda_\Delta\)</span> محاسبه شود.</p>
<p>پس از بدست آوردن ضریب <span class="math inline">\(\lambda_\Delta\)</span> باید تحلیل ترک خوردگی انجام شود تا ضرایب ترک خوردگی واقعی برای اعضا محاسبه شوند. برای این کار باید ابتدا تمامی ضرایب ترک خوردگی تیرها <strong>1</strong> قرار داده شوند. پس از اعمال ضریب ترک خوردگی 1 برای تیرها باید تحلیل ترک خوردگی را برای تیرها فعال کنیم. برای این کار ابتدا تمامی تیرها را انتخاب کرده و از طریق منوی <strong>Assign&gt;Frame&gt;Floor cracking</strong> تحلیل ترک خوردگی را برای آن ها در نظر میگیریم.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/beams_deflection/deflection-05.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/beams_deflection/deflection-06.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>بعداز انجام این مراحل باید <strong>لودکیس های غیرخطی</strong> مطابق با تصویر زیر برای انجام تحلیل ترک خوردگی تعریف شوند:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/beams_deflection/deflection-06_1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/beams_deflection/deflection-07.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="450"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/beams_deflection/deflection-08.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="450"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/beams_deflection/deflection-09.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="450"></p>
</figure>
</div>
<p>درصدی از بارهای زنده حالت <strong>ماندگار</strong> دارند و همانند بارهای مرده باعث ایجاد خزش میشوند. این درصد در متن آیین نامه مشخص نشده است و بر اساس قضاوت مهندس طراح تعیین میشود.</p>
<p>نکته: لودکیس شماره ۳ برای کنترل خیز تیر تحت بار مرده ۳ ماهه است که هنوز کف سازی ایجاد نشده است. در صورتی که کاربر بار <strong>Super Dead</strong> تعریف کرده باشد، این لودکیس ساخته شده و در خیز بلند مدت از مقدار خیز بلند مدت می کاهد . درصورتی که کاربر تعریف نکرده باشد، طبیعتا این لودکیس ساخته نمی شود که در جهت اطمینان می باشد.</p>
<p>در مرحله بعد باید ترکیب بارهای کنترل خیز ساخته شوند تا خیز تیر تحت این ترکیب بارها خواند و با مقادیر مجاز مقایسه شوند. ترکیب بارهای کنترل خیز عبارت اند از: <img src="figures/beams_deflection/deflection-11.png" class="img-fluid"></p>
<p>نکته: S.F به معنای ضریب لودکیس ها در ترکیب بار می باشند. . به عنوان مثال ضریب لودکیس ۳ باید برابر <span class="math inline">\(\lambda_\Delta\)</span> محاسبه شده باشد.</p>
<p>مقادیر مجاز خیز نیز از طریق جدول <strong>9-19-3</strong> برداشت شده است.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/beams_deflection/deflection-12.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>برای مشاهده خیز تیر در ایتبس ، بعد از تحلیل سازه از طریق گزینه مشخص شده در شکل زیر ، تحت هر یک از ترکیب بارهای کنترل خیز ،مقدار <strong>خیز نسبی</strong> برداشت شده و با مقدار مجاز مقایسه می شود.</p>
<p><img src="figures/beams_deflection/deflection-13.png" class="img-fluid" width="450"></p>
<p><img src="figures/beams_deflection/deflection-14.png" class="img-fluid" width="700"></p>
<p>به طور مثال در شکل بالا خیز نسبی تیر (Relative to Beam Ends) تحت ترکیب بار deflection1 مقدار 2.0969 بدست آمده است.</p>
</div>
<div id="tabset-1-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-3-tab">
<p>همانطور که می دانید برای محاسبه خیز تیرها روش‌های مختلفی وجود دارد که نرم‌افزار سیویل‌تولز طبق روشی که در ادامه توضیح خواهیم داد محاسبه <strong>خیز تیرهای بتنی</strong> را انجام داده و نتایج را به صورت اتوماتیک به کاربر نمایش میدهد.</p>
<p>ابتدا به بررسی بندهای آیین‌نامه‌ای مربوط به کنترل خیز میپردازیم و سپس نحوه محاسبه خیز تیر را شرح می‌دهیم.</p>
<p><img src="figures/beams_deflection/deflection-01.png" class="img-fluid" width="600"> <img src="figures/beams_deflection/deflection-02.png" class="img-fluid" width="600"> <img src="figures/beams_deflection/deflection-03.png" class="img-fluid" width="600"> <img src="figures/beams_deflection/deflection-04.png" class="img-fluid" width="600"></p>
<p>با توجه به بند های بالا، اشاره به چند نکته ضروری است:</p>
<p><strong>۱-</strong> برای کنترل خیز ترکیب بارها باید درحالت <strong>بهره برداری</strong> و بدون ضریب باشند.</p>
<p><strong>۲-</strong> در محاسبه خیز باید <strong>اثر ترک خوردگی و وجود آرماتور ها</strong> در نظر گرفته شود.</p>
<p><strong>۳-</strong> علاوه بر تغییرمکان‌های کوتاه‌مدت، باید تغییرمکان‌های ناشی از بارهای دائمی که همان بارهای مرده به علاوه <strong>درصدی</strong> از بارهای زنده است نیز منظور شود.</p>
<p><strong>۴-</strong> تغییرمکان طولانی‌مدت را میتوان با استفاده از حاصلضرب تغییرمکانهای آنی در ضریب <span class="math inline">\(\lambda_\Delta\)</span> محاسبه کرد.</p>
</div>
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>